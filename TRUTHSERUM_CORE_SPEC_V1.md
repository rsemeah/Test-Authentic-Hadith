# TruthSerum Core Specification v1.0

**Status**: Constitutional Document  
**Date**: January 13, 2026  
**Purpose**: Define truth infrastructure for Authentic Hadith platform  
**Principle**: No claim without proof. No proof without audit trail.

---

## Core Axiom

**Every truth-bearing operation must:**

1. Generate a deterministic content hash
2. Reference immutable source data
3. Emit a verifiable proof receipt
4. Log to append-only audit trail
5. Allow independent verification

**If an operation cannot do all 5, it cannot claim truth.**

---

## 1Ô∏è‚É£ Verification Primitive (Base Type)

All truth-bearing entities inherit from this primitive.

### TypeScript Interface

```typescript
/**
 * Core verification primitive - immutable proof of content integrity
 * Every truth-bearing entity MUST include this
 */
interface VerificationPrimitive {
  // Content integrity
  content_hash: string            // SHA-256 of canonical content (deterministic)
  content_version: number         // Monotonic version counter
  
  // Source attribution
  source_id: string               // Immutable reference to source artifact
  source_hash: string             // SHA-256 of original source document
  source_page?: string            // Physical page reference if applicable
  
  // Verification metadata
  verification_method: VerificationMethod
  verified_at: string             // ISO 8601 timestamp
  verified_by: string             // system | scholar:{id} | import:{pipeline_id}
  
  // Audit trail
  verification_signature: string  // HMAC-SHA256(content_hash + source_hash + verified_at, SECRET)
  previous_hash?: string          // Hash of previous version (for audit chain)
}

type VerificationMethod = 
  | 'source_import'      // Imported from authenticated source
  | 'scholar_reviewed'   // Verified by human scholar
  | 'cross_referenced'   // Verified against multiple sources
  | 'system_generated'   // Generated by system (lower trust)
  | 'user_contributed'   // User-contributed (requires review)

/**
 * Compute deterministic content hash
 * Rules: UTF-8 encoding, normalize whitespace, remove BOM, lowercase metadata keys
 */
function computeContentHash(content: unknown): string {
  const normalized = JSON.stringify(content, Object.keys(content).sort())
  return crypto.subtle.digest('SHA-256', new TextEncoder().encode(normalized))
}
```

### Database Schema (Supabase)

```sql
-- Core verification fields - add to every truth-bearing table
ALTER TABLE hadith ADD COLUMN IF NOT EXISTS verification JSONB NOT NULL DEFAULT '{}'::jsonb;

-- Verification index for fast lookups
CREATE INDEX idx_hadith_verification_hash ON hadith ((verification->>'content_hash'));
CREATE INDEX idx_hadith_verification_status ON hadith ((verification->>'verified_at'));

-- Constraint: verification must have required fields
ALTER TABLE hadith ADD CONSTRAINT verification_complete CHECK (
  verification ? 'content_hash' AND
  verification ? 'source_id' AND
  verification ? 'verified_at' AND
  verification ? 'verification_method'
);
```

---

## 2Ô∏è‚É£ Proof Receipt Format (Single Standard)

Every operation that touches truth-bearing data MUST emit a proof receipt.

### TypeScript Interface

```typescript
/**
 * Proof Receipt - verifiable record of every truth-bearing operation
 * Emit one receipt per operation. Store in audit log.
 */
interface ProofReceipt<TInput = unknown, TOutput = unknown> {
  // Operation identity
  receipt_id: string              // UUID v4
  operation: OperationType        // What was done
  operation_version: string       // API version (e.g., "v1.0.0")
  
  // Request context
  request_id: string              // Trace ID for debugging
  timestamp: string               // ISO 8601 when operation started
  duration_ms: number             // How long operation took
  
  // Inputs (what was requested)
  inputs: {
    hash: string                  // SHA-256 of input parameters
    params: TInput                // Actual input (sanitized of PII)
  }
  
  // Outputs (what was returned)
  outputs: {
    hash: string                  // SHA-256 of output data
    count: number                 // Number of entities returned
    entity_ids: string[]          // IDs of entities (for audit trail)
  }
  
  // Verification proof
  verification: {
    all_verified: boolean         // Were ALL outputs verified?
    verified_count: number        // How many entities passed verification
    unverified_count: number      // How many could not be verified
    verification_failures?: {     // If any failed, why?
      entity_id: string
      reason: string
    }[]
  }
  
  // Truth attestation
  attestation: {
    signature: string             // HMAC-SHA256 of entire receipt
    signer: string                // service:{name} | user:{id}
    confidence: ConfidenceLevel   // How confident are we?
  }
  
  // Audit trail link
  audit_log_id: string            // Reference to append-only log entry
  previous_receipt_id?: string    // Link to previous receipt (if chained operation)
}

type OperationType =
  | 'GET_HADITH'
  | 'SEARCH_HADITH'
  | 'AI_EXPLAIN'
  | 'SAFETY_CHECK'
  | 'USER_SAVE'
  | 'CREATE_NOTE'
  | 'VERIFY_CONTENT'

type ConfidenceLevel =
  | 'verified'        // 100% - All sources checked and verified
  | 'high'           // 95%+ - Sources checked, minor gaps
  | 'medium'         // 80%+ - Most sources checked
  | 'low'            // <80% - Limited verification
  | 'unverified'     // 0% - No verification performed
```

### Database Schema (Audit Log)

```sql
-- Append-only audit log - NEVER delete or update
CREATE TABLE IF NOT EXISTS audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  receipt JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  partition_key DATE NOT NULL DEFAULT CURRENT_DATE
) PARTITION BY RANGE (partition_key);

-- Prevent updates and deletes (append-only)
CREATE RULE audit_log_no_update AS ON UPDATE TO audit_log DO INSTEAD NOTHING;
CREATE RULE audit_log_no_delete AS ON DELETE TO audit_log DO INSTEAD NOTHING;

-- Index for fast lookups
CREATE INDEX idx_audit_log_receipt_id ON audit_log ((receipt->>'receipt_id'));
CREATE INDEX idx_audit_log_operation ON audit_log ((receipt->>'operation'));
CREATE INDEX idx_audit_log_timestamp ON audit_log ((receipt->>'timestamp'));
```

---

## 3Ô∏è‚É£ Truth-Bearing Entity Schemas

### Hadith (Primary Entity)

```typescript
interface Hadith extends VerificationPrimitive {
  // Identity
  id: string                      // UUID v4
  hadith_number: number           // Sequential number within collection
  
  // Content (canonical form)
  arabic_text: string             // Original Arabic (normalized)
  english_translation: string     // Primary translation
  
  // Attribution
  collection: string              // Sahih Bukhari, Sahih Muslim, etc.
  book: string                    // Book within collection
  chapter: string                 // Chapter within book
  
  // Narrator chain (isnad)
  narrator_chain: string[]        // Full chain from Prophet to compiler
  narrator_chain_hash: string     // Hash of complete chain (for integrity)
  
  // Grading
  grade: HadithGrade
  grade_source: string            // Who graded it (scholar name/org)
  grade_reasoning?: string        // Why this grade (optional)
  
  // Verification (from VerificationPrimitive)
  verification: VerificationPrimitive
  
  // Metadata
  created_at: string
  updated_at: string
  version: number                 // Content version (increments on edit)
}

type HadithGrade = 
  | 'sahih'          // Authentic
  | 'hasan'          // Good
  | 'daif'           // Weak
  | 'mawdu'          // Fabricated

// Compute hadith content hash (deterministic)
function computeHadithHash(hadith: Partial<Hadith>): string {
  const canonical = {
    arabic_text: hadith.arabic_text?.trim(),
    collection: hadith.collection,
    hadith_number: hadith.hadith_number,
    narrator_chain: hadith.narrator_chain
  }
  return computeContentHash(canonical)
}
```

### AI Explanation (Derived Entity)

```typescript
interface AIExplanation extends VerificationPrimitive {
  // Identity
  id: string                      // UUID v4
  hadith_id: string               // Reference to source hadith
  
  // Content
  explanation: string             // AI-generated explanation
  explanation_hash: string        // Hash of explanation text
  
  // Sources (REQUIRED - no explanation without sources)
  citations: Citation[]
  citation_coverage: number       // % of explanation backed by citations (target: 100%)
  
  // Model metadata
  model: string                   // gpt-4, gpt-3.5-turbo, etc.
  model_version: string           // Exact version for reproducibility
  temperature: number             // Generation params
  tokens_used: number
  
  // Safety check
  safety_check: {
    passed: boolean
    patterns_triggered: string[]
    blocked_content?: string      // If filtered, what was removed
  }
  
  // Verification (lower confidence than hadith)
  verification: VerificationPrimitive & {
    verification_method: 'system_generated'  // AI is always system_generated
  }
  
  // Metadata
  created_at: string
  regenerated_count: number       // How many times regenerated
}

interface Citation {
  hadith_id: string               // Which hadith was cited
  hadith_hash: string             // Hash at time of citation (immutable proof)
  excerpt: string                 // Specific text cited
  relevance: 'primary' | 'supporting' | 'contextual'
}
```

### SafetyEngine Decision (Audit Entity)

```typescript
interface SafetyDecision extends VerificationPrimitive {
  // Identity
  id: string                      // UUID v4
  query_hash: string              // Hash of input query
  
  // Input
  query: string                   // User's query (sanitized)
  query_metadata: {
    language: string
    length: number
    contains_arabic: boolean
  }
  
  // Decision
  decision: 'allowed' | 'blocked'
  confidence: number              // 0-1, how confident in decision
  
  // Pattern matching
  patterns_matched: PatternMatch[]
  total_patterns_checked: number
  
  // Outcome tracking
  false_positive_flagged: boolean // Did user report false positive?
  reviewed_by_human: boolean      // Did human review this decision?
  review_outcome?: 'correct' | 'incorrect' | 'unclear'
  
  // Verification (self-verifying)
  verification: VerificationPrimitive & {
    verification_method: 'system_generated'
    source_id: 'safetyengine:v1'  // Safety rules version
  }
  
  // Metadata
  created_at: string
  user_id?: string                // If logged in
  session_id: string              // Anonymous session
}

interface PatternMatch {
  pattern_id: string              // Which pattern matched
  pattern_category: string        // Category (sectarianism, violence, etc.)
  match_text: string              // What text matched
  severity: 'low' | 'medium' | 'high' | 'critical'
}
```

---

## 4Ô∏è‚É£ Enforcement Rules

These rules are **non-negotiable** for any truth-bearing operation.

### Rule 1: No Unverified Reads

```typescript
/**
 * ENFORCE: Cannot serve unverified content to users
 */
async function getHadith(id: string): Promise<Hadith> {
  const hadith = await db.from('hadith').select('*').eq('id', id).single()
  
  // ENFORCE: Must have verification
  if (!hadith.verification?.content_hash) {
    throw new UnverifiedContentError(`Hadith ${id} lacks verification`)
  }
  
  // ENFORCE: Verify hash matches content
  const computedHash = computeHadithHash(hadith)
  if (computedHash !== hadith.verification.content_hash) {
    throw new IntegrityViolationError(`Hadith ${id} hash mismatch`)
  }
  
  // EMIT: Proof receipt
  await emitReceipt({
    operation: 'GET_HADITH',
    inputs: { id },
    outputs: { entity_ids: [id] },
    verification: { all_verified: true, verified_count: 1 }
  })
  
  return hadith
}
```

### Rule 2: No Citation-less AI Responses

```typescript
/**
 * ENFORCE: AI must cite sources or refuse to answer
 */
async function explainHadith(hadithId: string, question: string): Promise<AIExplanation> {
  const hadith = await getHadith(hadithId)  // Already verified
  
  const response = await openai.chat.completions.create({
    messages: [
      { role: 'system', content: 'You MUST cite specific hadith text in your explanation.' },
      { role: 'user', content: question }
    ]
  })
  
  const citations = extractCitations(response.content, hadith)
  
  // ENFORCE: Must have at least one citation
  if (citations.length === 0) {
    throw new NoCitationError('AI response lacks hadith citations')
  }
  
  // ENFORCE: Citations must be verifiable
  for (const citation of citations) {
    const citedHadith = await getHadith(citation.hadith_id)
    citation.hadith_hash = citedHadith.verification.content_hash
  }
  
  const explanation: AIExplanation = {
    id: crypto.randomUUID(),
    hadith_id: hadithId,
    explanation: response.content,
    explanation_hash: computeContentHash(response.content),
    citations,
    citation_coverage: calculateCoverage(response.content, citations),
    model: response.model,
    // ... rest
  }
  
  // EMIT: Proof receipt
  await emitReceipt({
    operation: 'AI_EXPLAIN',
    inputs: { hadith_id: hadithId, question },
    outputs: { entity_ids: [explanation.id] },
    verification: { all_verified: true, verified_count: 1 }
  })
  
  return explanation
}
```

### Rule 3: No Unmeasured Safety

```typescript
/**
 * ENFORCE: Every safety decision must be logged and measurable
 */
async function checkSafety(query: string, userId?: string): Promise<SafetyDecision> {
  const queryHash = computeContentHash({ query, timestamp: Date.now() })
  
  const patterns = await loadSafetyPatterns()
  const matches = patterns.filter(p => p.regex.test(query))
  
  const decision: SafetyDecision = {
    id: crypto.randomUUID(),
    query_hash: queryHash,
    query: sanitize(query),
    decision: matches.length > 0 ? 'blocked' : 'allowed',
    confidence: calculateConfidence(matches),
    patterns_matched: matches.map(m => ({
      pattern_id: m.id,
      pattern_category: m.category,
      match_text: m.regex.exec(query)?.[0] || '',
      severity: m.severity
    })),
    total_patterns_checked: patterns.length,
    false_positive_flagged: false,
    reviewed_by_human: false,
    verification: {
      verification_method: 'system_generated',
      verified_at: new Date().toISOString(),
      verified_by: 'system',
      source_id: 'safetyengine:v1',
      content_hash: queryHash,
      source_hash: computeContentHash(patterns),
      verification_signature: signContent(queryHash)
    },
    created_at: new Date().toISOString(),
    user_id: userId,
    session_id: getSessionId()
  }
  
  // ENFORCE: Must log to audit trail
  await db.from('safety_decisions').insert(decision)
  
  // EMIT: Proof receipt
  await emitReceipt({
    operation: 'SAFETY_CHECK',
    inputs: { query_hash: queryHash },
    outputs: { entity_ids: [decision.id] },
    verification: { all_verified: true, verified_count: 1 }
  })
  
  return decision
}
```

### Rule 4: No Count Without Database Query

```typescript
/**
 * ENFORCE: Never hardcode counts - always query database
 */
async function getVerifiedHadithCount(): Promise<number> {
  const { count } = await db
    .from('hadith')
    .select('*', { count: 'exact', head: true })
    .not('verification->content_hash', 'is', null)
  
  // EMIT: Proof receipt
  await emitReceipt({
    operation: 'COUNT_HADITH',
    inputs: { filter: 'verified_only' },
    outputs: { count, entity_ids: [] },
    verification: { all_verified: true, verified_count: count }
  })
  
  return count
}

// ‚ùå FORBIDDEN
const TOTAL_HADITH = 36245  // Never do this

// ‚úÖ REQUIRED
const totalHadith = await getVerifiedHadithCount()
```

---

## 5Ô∏è‚É£ Receipt Storage & Retrieval

### Emit Receipt Function

```typescript
/**
 * Emit proof receipt and store in audit log
 * MUST be called by every truth-bearing operation
 */
async function emitReceipt<TInput, TOutput>(
  receipt: Omit<ProofReceipt<TInput, TOutput>, 'receipt_id' | 'attestation' | 'audit_log_id'>
): Promise<string> {
  const receiptId = crypto.randomUUID()
  
  const fullReceipt: ProofReceipt<TInput, TOutput> = {
    receipt_id: receiptId,
    ...receipt,
    attestation: {
      signature: signReceipt(receipt),
      signer: 'service:api',
      confidence: determineConfidence(receipt.verification)
    },
    audit_log_id: ''  // Will be set after insert
  }
  
  // Store in append-only audit log
  const { data } = await db
    .from('audit_log')
    .insert({ receipt: fullReceipt })
    .select('id')
    .single()
  
  fullReceipt.audit_log_id = data.id
  
  return receiptId
}
```

### Retrieve Receipt Function

```typescript
/**
 * Retrieve proof receipt for verification
 * Users/scholars can verify any operation
 */
async function getReceipt(receiptId: string): Promise<ProofReceipt> {
  const { data } = await db
    .from('audit_log')
    .select('receipt')
    .eq('receipt->receipt_id', receiptId)
    .single()
  
  if (!data) {
    throw new ReceiptNotFoundError(receiptId)
  }
  
  // Verify signature
  const isValid = verifyReceiptSignature(data.receipt)
  if (!isValid) {
    throw new TamperedReceiptError(receiptId)
  }
  
  return data.receipt
}
```

---

## 6Ô∏è‚É£ SafetyEngine Measurement Schema

### Effectiveness Tracking

```sql
-- SafetyEngine effectiveness metrics (updated in real-time)
CREATE TABLE IF NOT EXISTS safety_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
  
  -- Volume
  total_queries INTEGER NOT NULL DEFAULT 0,
  blocked_queries INTEGER NOT NULL DEFAULT 0,
  allowed_queries INTEGER NOT NULL DEFAULT 0,
  
  -- Accuracy (requires human review)
  false_positives INTEGER NOT NULL DEFAULT 0,
  false_negatives INTEGER NOT NULL DEFAULT 0,
  true_positives INTEGER NOT NULL DEFAULT 0,
  true_negatives INTEGER NOT NULL DEFAULT 0,
  
  -- By category
  blocked_by_category JSONB NOT NULL DEFAULT '{}'::jsonb,
  
  -- Effectiveness
  precision DECIMAL(5, 4),  -- true_positives / (true_positives + false_positives)
  recall DECIMAL(5, 4),     -- true_positives / (true_positives + false_negatives)
  f1_score DECIMAL(5, 4),   -- 2 * (precision * recall) / (precision + recall)
  
  -- Computed timestamps
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(metric_date)
);

-- Update metrics after every safety decision
CREATE OR REPLACE FUNCTION update_safety_metrics()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO safety_metrics (metric_date, total_queries, blocked_queries, allowed_queries)
  VALUES (CURRENT_DATE, 0, 0, 0)
  ON CONFLICT (metric_date) DO NOTHING;
  
  UPDATE safety_metrics
  SET 
    total_queries = total_queries + 1,
    blocked_queries = blocked_queries + CASE WHEN NEW.decision = 'blocked' THEN 1 ELSE 0 END,
    allowed_queries = allowed_queries + CASE WHEN NEW.decision = 'allowed' THEN 1 ELSE 0 END,
    updated_at = NOW()
  WHERE metric_date = CURRENT_DATE;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER safety_decision_metrics
AFTER INSERT ON safety_decisions
FOR EACH ROW EXECUTE FUNCTION update_safety_metrics();
```

---

## 7Ô∏è‚É£ Implementation Checklist

### Phase 2.5: TruthSerum Infrastructure

**‚úÖ = Must complete before Phase 3**

#### Database Layer

- [ ] Add `verification` JSONB column to `hadith` table
- [ ] Add `verification` JSONB column to `ai_explanations` table
- [ ] Create `audit_log` table (append-only, partitioned)
- [ ] Create `safety_decisions` table
- [ ] Create `safety_metrics` table
- [ ] Add verification constraints and indexes
- [ ] Create trigger for safety metrics updates
- [ ] Prevent updates/deletes on audit_log

#### Core Library (`/lib/truthserum/`)

- [ ] Create `types.ts` (all interfaces from this spec)
- [ ] Create `verification.ts` (hash functions, primitives)
- [ ] Create `receipts.ts` (emit, retrieve, verify)
- [ ] Create `enforcement.ts` (rule enforcement functions)
- [ ] Create `signatures.ts` (HMAC signing/verification)
- [ ] Create `index.ts` (exports)

#### API Middleware

- [ ] Create `withVerification` middleware (enforces verification on reads)
- [ ] Create `withReceipt` middleware (emits receipt on all operations)
- [ ] Create `withSafety` middleware (logs all safety decisions)
- [ ] Apply middleware to all API routes

#### Retrofit Existing Code

- [ ] Update `GET /api/hadith/[id]` with verification
- [ ] Update `POST /api/hadith/search` with verification
- [ ] Update `POST /api/ai/explain` with citations
- [ ] Update SafetyEngine to log all decisions
- [ ] Remove all hardcoded counts (replace with DB queries)
- [ ] Add citation extraction to AI responses

#### Testing

- [ ] Test verification hash consistency
- [ ] Test receipt emission on all operations
- [ ] Test enforcement rules (should reject unverified content)
- [ ] Test signature verification
- [ ] Test audit log immutability
- [ ] Test safety metrics calculation

---

## 8Ô∏è‚É£ Success Criteria

**Phase 2.5 is complete when:**

1. ‚úÖ Every hadith has a `content_hash` and cannot be served without it
2. ‚úÖ Every API operation emits a verifiable proof receipt
3. ‚úÖ All receipts are stored in append-only audit log
4. ‚úÖ AI explanations refuse to answer without citations
5. ‚úÖ SafetyEngine logs every decision with patterns matched
6. ‚úÖ No hardcoded counts exist - all counts query database
7. ‚úÖ All enforcement rules pass automated tests
8. ‚úÖ Documentation updated to reference verification system

**Verification Test:**

```bash
# Run this query - should return 0
SELECT COUNT(*) FROM hadith WHERE verification IS NULL OR verification->>'content_hash' IS NULL;

# Run this query - should match total hadith count
SELECT COUNT(*) FROM audit_log WHERE receipt->>'operation' = 'GET_HADITH';
```

---

## 9Ô∏è‚É£ What This Enables (Post-Phase 2.5)

**For Users:**

- Verify any hadith's authenticity themselves (check hash against source)
- See proof receipts for all operations
- Report false positives with audit trail

**For Scholars:**

- Audit platform's data integrity
- Review AI explanation citations
- Verify narrator chain accuracy
- Access proof receipts for any operation

**For Platform:**

- Defend authenticity claims with cryptographic proof
- Measure SafetyEngine effectiveness empirically
- Generate compliance reports from audit log
- Detect data tampering immediately
- Build trust through transparency

**For Marketing:**

- "Every hadith verified" (provable, not aspirational)
- "36,245 verified hadith" (database-backed, not hardcoded)
- "AI explanations with citations" (enforced by code)
- "Measurable safety" (real-time metrics, not claims)

---

## üîê Final Principle

**From this point forward:**

> If it claims truth, it must have proof.
> If it has proof, it must be auditable.
> If it's auditable, it must be verifiable.

No exceptions.

---

**Status**: Ready for implementation  
**Next Step**: Create `/lib/truthserum/` directory and implement core types  
**Document Version**: 1.0.0  
**Last Updated**: January 13, 2026
